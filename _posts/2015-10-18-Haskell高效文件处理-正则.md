---
layout: post 
category: haskell
tags: [ read , haskell ]
---
{% include JB/setup %}
#Haskell
* String为Char列表,`列表的每个元素被单独分配内存`，并有一定的写入开销。对那些要读取文本及二进制数据的程序来说，这些因素会影响内存消耗和执行效率。
* 使用ByteString代替
* `Data.ByteString` 定义了一个名为 ByteString 的严格类型，其将一个字符串或二进制数据或文本用`一个数组`表示。
* `Data.ByteString.Lazy` 模块定义了一个`惰性类型`，同样命名为 ByteString 。其将字符串数据表示为一个由`块`组成的`列表`，每个`块`是大小为`64KB的数组`。
* 两种 ByteString 适用于不同的场景。对于`大体积`的文件流(几百 MB 至几 TB)，最好使用`Lazy的ByteString` 。其块的大小被调整得对现代 CPU 的 L1 缓存特别友好，并且在`流中已经被处理过块可以被垃圾收集器快速丢弃`。对于`不在意内存`占用而且需要`随机访问`的数据，最好使用`严格`的 ByteString 类型。


###正则表达式
{% highlight haskell %}
ghci> :module +Text.Regex.Posix
ghci> :type (=~)
(=~)
  :: (RegexContext Regex source1 target,
      RegexMaker Regex CompOption ExecOption source) =>
     source1 -> source -> target
{% endhighlight %}
=~ 操作符的参数和返回值都使用了`类型类`。第一个参数 (=~ 左侧) 是要被匹配的文本；第二个参数 (=~ 右侧) 是准备匹配的正则表达式。对每个参数我们都可以使用 String 或者 ByteString 。

###`结果的多类型` 
* =~ 操作符的返回类型是多态的，
* 可以通过指定结果的类型，返回不同类型的结果
{% highlight haskell %}
ghci> "your right hand" =~ "bar" :: Bool
False
ghci> "a star called planet" =~ "planet" :: Int
1
ghci> "I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: String
ghci> "I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: String
"ii"
ghci> "I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: [[String]]
[["ii","ii"],["uu","uu"]]
{% endhighlight %}
注意 String 类型的结果,指定结果为普通的字符串时，要当心。因为 (=~) 在表示 “无匹配” 时会返回`空字符串`，很明显这导致了`难`以处理可以`匹配空字符串`的正则表达式。这情况出现时，就需要使用另一种不同的结果类型，比如 [[String]]。

* 函数具有`多态返回值`的能力对于一个静态类型语言来说是个不同寻常的特性。

###不同类型字符串的混合与匹配
* 文本匹配的`结果`必须于`被匹配`的字符串`类型`一致
{% highlight haskell %}
ghci> pack "good food" =~ ".ood" :: [[ByteString]]
[["good"],["food"]]
--error 
ghci> "good food" =~ ".ood" :: [[ByteString]]
{% endhighlight %}
* `正则表达式`不存在这个限制。正则表达式可以是 String 或 ByteString ，而不必在意输入或结果是何种类型。
